# Confirm Mode

## 定义
确认包模式是用于节点设备，确认数据包的的确确传输到NS上，并被NS确认

## 现有的确认包模式：
当节点开启确认包模式后，每上行一个包，并等待NS下行ACK以证明该数据包


#### 小故事：
在一个小镇的地铁站（节点设备），每隔一段时间发车（周期上行），正常时候，每班车都会上一个人（一个包带一个数据），然后坐车去市中心上班（上行到NS）。
这个车正常可以坐10个人（包的长度为10B），但是由于我需要尽可能将人快点送过去，因此我选择多发车，这也就导致虽然车还有9个空位，也需要直接发车了。
如果当第一个人在车站等车，这一趟本该来却并未按时出现的时候（没有收到确认包），他只能在原地等候，这个时候第二个人也来了，并在第一个人后面排队。
这个时候，第两个人发现第二部车也没有来，所以只能继续等候，直到第n个人到来，例如这个时候第8个人来了的时候，车也来了，于是所有人都坐上车，发现车正好坐得下（所有队列中的数据没有超过载荷大小Payload Size），遂发车（统一发送到NS）。


当开启了Confirm Mode的时候，设备会需要在最近一次重新入网时和NS协商开启重新入网模式，并让NS在后续每收到一个包的时候，都下发一个ACK，也就是确认包。


在正常的上行中，我们有一个长度限制的队列。

若当节点上行一个包且未收到确认包回复时，会记录

NS端

> 当NS开启了确认包模式后，每当NS收到一条终端节点的上行包，都会下发一条“确认包”作为回应。
> 

节点端
> 当节点开启确认包模式后，每个上行包都需要收到确认包时，这个数据包才被认为是“确认被接受”。
> 
> 当第一个数据包没有收到确认包时，该数据的时间戳将会入队，然后尝试重发一次该数据。
> + 该重发次数默认不可以调整并限制为1
> + 主要原因是：最开始的时候重发次数为3，但是由于数据在信号比较极限的情况下，较多数据包都被发送四次（首次加上重发三次），导致空中的信道被占用堵塞，经过多次实地测试，最终选择为1，这样既可以保证至少被重发一次的同时，也不会过多占用信道
> + 该逻辑可以修改调整，经过研发定制。
> 
> 若重发次数修改为大于一时，设重发次数为N，则会有以下逻辑：
> + 数据正常发送
> + 等待时间，未接受到下行确认包
> + 判定为该数据包丢失 n=0
> + 该数据包时间戳入队
> + "重发机制触发"
> + 发送第一次重发包
> + 等待时间，未接受到下行确认包
> + 判定该重发包丢失 n=1
> + 发送第二次重发包
> + ...
> + 发送第N次重发包
> + 等待时间，未接受到下行确认包
> + 判定该重发包丢失 n=N
> + “先不发了，下一个！”
> 
> 然后下一个数据包在网络不好的情况下会进入上述循环，直到被其他因素中断
> 
> 若开启了Rejoin Mode，
